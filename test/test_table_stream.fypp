#:include "../src/common.fypp"

program test_table
 use iso_fortran_env, only: int32, real32
 use modtable, only: table_char_t, table_int32_t, table_real32_t, table_arrint32_t, table_arrreal32_t, table_char_fmt
 implicit none

 call test_char()

 #:for t,k,l,m in NTYPES
 call test_${k}$ ()
 call test_read_${k}$ ()
 call test_arr${k}$ ()
 call test_read_arr${k}$ ()
 #:endfor

! call test_arrint32()
! call test_arrreal32()

contains

 subroutine test_char()
  type(table_char_t) :: table

  integer :: i, io, un
  integer(int32) :: nfilled, nsize, nstorage
  character(len=:), allocatable :: nvalue
  character(len=:), allocatable :: namefile

  integer, parameter :: len_c = 15
  character(len=*), parameter :: input(*) = [character(len=len_c) :: "c10", "c11", "c111", "c2222" &
                                                                    , "c22", "c333", "c-5", "c44" &
                                                                    , "c-9", "c1000", "c-23"]

  table = table_char_t(k=len_c, nel=size(input))

  do i = 1, size(input)
   call table%add(input(i))
  end do

  call check(table%getfilled() == size(input), 'char: issue with initial filled')

  namefile = 'table_char.stream'
  call table%writestream(namefile)

  open (newunit=un, file=namefile, status='old', action='read', access='stream', iostat=io)

  read (un, iostat=io) nfilled
  call check(io == 0, 'char: issue with reading nfilled')
  call check(nfilled == size(input), 'char: issue with nfilled: wrong value')

  read (un, iostat=io) nsize
  call check(io == 0, 'char: issue with reading nsize')
  call check(nsize == 1_int32, 'char: issue with nsize: wrong value')

  read (un, iostat=io) nstorage
  call check(io == 0, 'char: issue with reading nstorage')
  call check(nstorage == storage_size(input(1), kind=int32)/8, 'char: issue with nstorage: wrong value')

  allocate (character(len=nstorage) :: nvalue)

  do i = 1, nfilled
   read (un, iostat=io) nvalue
   call check(io == 0, 'char: issue with reading nvalue')
   call check(nvalue == input(i), 'char: issue with value: wrong value')
  end do

  close (un)

  print *, 'Successful writestream char'

 end subroutine

 #:for t,k,l,m in NTYPES
 subroutine test_${k}$ ()
  type(table_${k}$_t) :: table

  integer :: i, io, un
  integer(int32) :: nfilled, nsize, nstorage
  ${t}$::nvalue
  character(len=:), allocatable :: namefile

  ${t}$, parameter :: input(*) = ${m}$ ([10, 11, 111, 2222 &
                                         , 22, 333, -5, 44 &
                                         , -9, 1000, -23], kind=${k}$)

  table = table_${k}$_t(nel=size(input))

  do i = 1, size(input)
   call table%add(input(i))
  end do

  call check(table%getfilled() == size(input), '${k}$: issue with initial filled')

  namefile = 'table_${k}$.stream'
  call table%writestream(namefile)

  open (newunit=un, file=namefile, status='old', action='read', access='stream', iostat=io)

  read (un, iostat=io) nfilled
  call check(io == 0, '${k}$: issue with reading nfilled')
  call check(nfilled == size(input), '${k}$: issue with nfilled: wrong value')

  read (un, iostat=io) nsize
  call check(io == 0, '${k}$: issue with reading nsize')
  call check(nsize == 1_int32, '${k}$: issue with nsize: wrong value')

  read (un, iostat=io) nstorage
  call check(io == 0, '${k}$: issue with reading nstorage')
  call check(nstorage == storage_size(input(1), kind=int32)/8, '${k}$: issue with nstorage: wrong value')

  do i = 1, nfilled
   read (un, iostat=io) nvalue
   call check(io == 0, '${k}$: issue with reading nvalue')
   call check(nvalue == input(i), '${k}$: issue with value: wrong value')
  end do

  close (un)

  print *, 'Successful writestream ${k}$'

 end subroutine

 subroutine test_read_${k}$ ()
  type(table_${k}$_t) :: table
  type(table_${k}$_t) :: table1

  integer :: i
  character(*), parameter :: namefile = 'table_${k}$.stream'

  ${t}$, parameter :: input(*) = ${m}$ ([10, 11, 111, 2222 &
                                         , 22, 333, -5, 44 &
                                         , -9, 1000, -23], kind=${k}$)

  table = table_${k}$_t(nel=size(input))

  do i = 1, size(input)
   call table%add(input(i))
  end do

  call check(table%getfilled() == size(input), '${k}$: issue with initial filled')

  call table%writestream(namefile)

  call table1%readstream(namefile)

  call check(table%getfilled() == table1%getfilled(), 'read_${k}$: issue with initial filled')

  do i = 1, table%getfilled()
   call check(table%get(i) == table1%get(i), 'read_${k}$: issue with value: wrong value')
  end do

  print *, 'Successful readstream ${k}$'

 end subroutine

 subroutine test_arr${k}$ ()
  type(table_arr${k}$_t) :: table

  integer :: i, io, un
  integer(int32) :: nfilled, nsize, nstorage
  ${t}$, allocatable :: nvalue(:)
  character(len=:), allocatable :: namefile

  ${t}$, parameter :: input(*, *) = ${m}$ (reshape([10, 11, 111, 2222 &
                                                    , 22, 333, -5, 44 &
                                                    , -9, 1000, -23, 99], [4, 3]), kind=${k}$)

  table = table_arr${k}$_t(size(input, 1), nel=size(input))

  do i = 1, size(input, 2)
   call table%add(input(:, i))
  end do

  call check(table%getfilled() == size(input, 2), 'arr${k}$: issue with initial filled')

  namefile = 'table_arr${k}$.stream'
  call table%writestream(namefile)

  open (newunit=un, file=namefile, status='old', action='read', access='stream', iostat=io)

  read (un, iostat=io) nfilled
  call check(io == 0, 'arr${k}$: issue with reading nfilled')
  call check(nfilled == size(input, 2), 'arr${k}$: issue with nfilled: wrong value')

  read (un, iostat=io) nsize
  call check(io == 0, 'arr${k}$: issue with reading nsize')
  call check(nsize == size(input, 1), 'arr${k}$: issue with nsize: wrong value')

  read (un, iostat=io) nstorage
  call check(io == 0, 'arr${k}$: issue with reading nstorage')
  call check(nstorage == storage_size(input(:, 1), kind=int32)/8, 'arr${k}$: issue with nstorage: wrong value')

  allocate (nvalue(nsize))

  do i = 1, nfilled
   read (un, iostat=io) nvalue
   call check(io == 0, 'arr${k}$: issue with reading nvalue')
   call check(all(nvalue == input(:, i)), 'arr${k}$: issue with value: wrong value')
  end do

  close (un)

  print *, 'Successful writestream arr${k}$'

 end subroutine

 subroutine test_read_arr${k}$ ()
  type(table_arr${k}$_t) :: table
  type(table_arr${k}$_t) :: table1

  integer :: i
  character(*), parameter :: namefile = 'table_arr${k}$.stream'
  ${t}$, parameter :: input(*, *) = ${m}$ (reshape([10, 11, 111, 2222 &
                                                    , 22, 333, -5, 44 &
                                                    , -9, 1000, -23, 555], [4, 3]), kind=${k}$)

  table = table_arr${k}$_t(size(input, 1), nel=size(input))

  do i = 1, size(input, 2)
   call table%add(input(:, i))
  end do

  call check(table%getfilled() == size(input, 2), 'arr${k}$: issue with initial filled')

  call table%writestream(namefile)

  call table1%readstream(namefile)

  call check(table%getfilled() == table1%getfilled(), 'read_arr${k}$: issue with initial filled')

  do i = 1, table%getfilled()
   call check(all(table%get(i) == table1%get(i)), 'read_arr${k}$: issue with value: wrong value')
  end do

  print *, 'Successful readstream arr${k}$'

 end subroutine

 #:endfor

 subroutine check(lcheck, a)
  logical, intent(in) :: lcheck
  character(*), intent(in), optional :: a

  if (.not. lcheck) then
   if (present(a)) print'(2a)', 'ERROR: ', a
   error stop
  end if
 end subroutine

end program
